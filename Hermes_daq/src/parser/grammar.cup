package parser;

import java_cup.runtime.ComplexSymbolFactory;
import java.util.*;
import parser.tree.*;
import parser.tree.expression.*;
import parser.tree.expression.operators.*;
import parser.tree.expression.literals.*;
import parser.tree.expression.operators.arithmetic.*;
import parser.tree.expression.operators.assignment.*;
import parser.tree.expression.operators.relational.*;
import parser.tree.expression.operators.logical.*;
import parser.tree.expression.operators.bits.*;
import parser.tree.expression.operators.unary.*;
import parser.tree.expression.operators.reduction.*;
parser code {:

    public parser(Lexer lex, ComplexSymbolFactory sf) {
        super(lex,sf);
    }

    public void report_error(String message, Object info) {

        StringBuilder m = new StringBuilder("Error");

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left));
                if (s.right >= 0)
                    m.append(", column "+(s.right));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }


    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};


terminal            COMMA, TERNARY_OP, COLON, OR_OP, AND_OP, OR, XOR, AND, EQUAL_OP, NOT_EQUAL_OP;
terminal            LSHIFT_OP, RSHIFT_OP, LESS_EQUAL_OP, GREATER_EQUAL_OP, LESS_OP, GREATER_OP;
terminal            INC_OP, DEC_OP, PLUS, MINUS, TIMES, DIV, MOD, RSQUARE_BRACKET, LSQUARE_BRACKET;
terminal            NOT, NOT_OP, LPARENTHESIS, RPARENTHESIS, ASSIGNMENT_OP, SEMICOLON;

terminal    Integer    INT_LITERAL;
// terminal String     STRING_LITERAL;
terminal    String     ID;

/* expression */
non terminal    ExpressionNode  expression, assignment_expression, conditional_expression, unary_expression;   
non terminal    ExpressionNode  logical_or_expression, logical_and_expression, inclusive_or_expression;   
non terminal    AssignmentOperator  assignment_operator;
non terminal    ExpressionNode  exclusive_or_expression, and_expression, equality_expression, relational_expression;   
non terminal    ExpressionNode  shift_expression, additive_expression, multiplicative_expression;
non terminal    ExpressionNode  postfix_expression, primary_expression;
non terminal    UnaryOperator   unary_operator;
non terminal    ArrayList<ExpressionNode>   argument_expression_list;
non terminal    ArrayList<IdNode>      id_list, opt_comma;   

start with program;

/* expression */
expression ::= assignment_expression:ae {:RESULT = ae;:}
    |   expression:e COMMA assignment_expression:ae 
        {:  Location l = new Location(eleft, eright);
            InLineExpressionNode ilen =  new InLineExpressionNode(l,e, ae); 
            RESULT = ilen;:} 
    ;

assignment_expression ::= conditional_expression:ce {:RESULT = ce;:}
    |   unary_expression:ue assignment_operator:ao assignment_expression:ae 
        {:  Variable va = (Variable)ue;
            ao.setVariable(va); ao.setRightNode(ae); RESULT = ao; :} 
    ;

conditional_expression ::= logical_or_expression:loe {:RESULT = loe;:}
    |   logical_or_expression:loe TERNARY_OP:to expression:e COLON conditional_expression:ce
        {:  Location l = new Location(toleft, toright);
            TernaryOperatorNode ton = new TernaryOperatorNode(l,loe, e, ce); 
            RESULT = ton;:} 
    ;

logical_or_expression ::= logical_and_expression:lae {:RESULT = lae;:}
    |   logical_or_expression:loe OR_OP:op logical_and_expression:lae
        {:  Location l = new Location(opleft, opright);
            OrOperatorNode oon = new OrOperatorNode(l,loe, lae); 
            RESULT = oon; :}
    ;

logical_and_expression ::= inclusive_or_expression:ioe {:RESULT = ioe; :}
    |   logical_and_expression:lae AND_OP:ao inclusive_or_expression:ioe
        {:  Location l = new Location(aoleft, aoright);
            AndOperatorNode aon = new AndOperatorNode(l,lae, ioe); RESULT = aon; :}
    ;

inclusive_or_expression ::= exclusive_or_expression:eoe {:RESULT = eoe; :}
    |   inclusive_or_expression:ioe OR:or exclusive_or_expression:eoe
        {:  Location l = new Location(orleft, orright);
            OrNode on = new OrNode(l,ioe, eoe); RESULT = on;:}
    ;

exclusive_or_expression ::= and_expression:ae {:RESULT = ae;:}
    |   exclusive_or_expression:eoe XOR:xor and_expression:ae
        {:  Location l = new Location(xorleft, xorright);
            XorNode xn = new XorNode(l,eoe,ae); RESULT = xn;:}
    ;

and_expression ::= equality_expression:ee {:RESULT = ee;:}
    |   and_expression:ae AND:a equality_expression:ee
        {:  Location l = new Location(aleft, aright);
            AndNode an = new AndNode(l,ae, ee); RESULT = an;:}
    ;

equality_expression ::= relational_expression:re {:RESULT = re;:}
    |   equality_expression:ee EQUAL_OP:e relational_expression:re 
        {:  Location l = new Location(eleft, eright);
            EqualOperatorNode eon = new EqualOperatorNode(l,ee,re); RESULT = eon;:}
    |   equality_expression:ee NOT_EQUAL_OP:n relational_expression:re 
        {:  Location l = new Location(nleft, nright);
            NotEqualOperatorNode neon = new NotEqualOperatorNode(l,ee,re); RESULT = neon;:}
    ;

relational_expression ::= shift_expression:se {:RESULT = se;:}
    |   relational_expression:re LESS_OP:lo shift_expression:se 
        {:  Location l = new Location(loleft, loright);
            LessOperatorNode lon = new LessOperatorNode(l,re,se); RESULT = lon;:}
    |   relational_expression:re GREATER_OP:g shift_expression:se 
        {:  Location l = new Location(gleft, gright);
            GreaterOperatorNode gon = new GreaterOperatorNode(l,re,se); RESULT = gon;:}
    |   relational_expression:re LESS_EQUAL_OP:lo shift_expression:se 
        {:  Location l = new Location(loleft, loright);
            LessEqualOperatorNode leon = new LessEqualOperatorNode(l,re,se); RESULT = leon;:}
    |   relational_expression:re GREATER_EQUAL_OP:g shift_expression:se 
        {:  Location l = new Location(gleft, gright);
            GreaterEqualOperatorNode geon = new GreaterEqualOperatorNode(l,re,se); RESULT = geon;:}
    ;

shift_expression ::= additive_expression:ae {:RESULT = ae;:}
    |   shift_expression:se LSHIFT_OP:ls additive_expression:ae 
        {:  Location l = new Location(lsleft, lsright);
            LeftShiftOperatorNode lson = new LeftShiftOperatorNode(l,se,ae); RESULT = lson;:}
    |   shift_expression:se RSHIFT_OP:r additive_expression:ae 
        {:  Location l = new Location(rleft, rright);
            RightShiftOperatorNode rson = new RightShiftOperatorNode(l,se,ae); RESULT = rson;:}
    ;

additive_expression ::= multiplicative_expression:me {:RESULT = me;:}
    |   additive_expression:ae PLUS:p multiplicative_expression:me 
        {:  Location l = new Location(pleft, pright);
            PlusOperatorNode pon = new PlusOperatorNode(l,ae,me); RESULT = pon;:}
    |   additive_expression:ae MINUS:m multiplicative_expression:me 
        {:  Location l = new Location(mleft, mright);
            MinusOperatorNode mon = new MinusOperatorNode(l,ae,me); RESULT = mon;:}
    ;

multiplicative_expression ::= unary_expression:ue {:RESULT = ue;:}
    |   multiplicative_expression:me TIMES:t unary_expression:ue 
        {:  Location l = new Location(tleft, tright);
            TimesOperatorNode ton = new TimesOperatorNode(l,me, ue); RESULT = ton;:}
    |   multiplicative_expression:me DIV:d unary_expression:ue 
        {:  Location l = new Location(dleft, dright);
            DivOperatorNode don = new DivOperatorNode(l,me, ue); RESULT = don;:}
    |   multiplicative_expression:me MOD:m unary_expression:ue 
        {:  Location l = new Location(mleft, mright);
            ModOperatorNode mon = new ModOperatorNode(l,me, ue); RESULT = mon;:}
    ;

unary_expression ::= postfix_expression:pe {:RESULT = pe;:}
    |   INC_OP:i unary_expression:ue 
        {:  Location l = new Location(ileft, iright);
            PreIncrementOperatorNode pion = new PreIncrementOperatorNode(l,ue); RESULT = pion;:}
    |   DEC_OP:d unary_expression:ue 
        {:  Location l = new Location(dleft, dright);
            PreDecrementOperatorNode pdon = new PreDecrementOperatorNode(l,ue); RESULT = pdon;:}
    |   AND:a  LSQUARE_BRACKET id_list:il RSQUARE_BRACKET 
        {:  Location l = new Location(aleft, aright);
            AndReductionNode arn = new AndReductionNode(l,il); RESULT = arn;:}
    | unary_operator:op unary_expression:ue {:op.setExpression(ue); RESULT = op;:} 
    ;

id_list ::= ID:i opt_comma:oc 
        {:   Location l = new Location(ileft,iright);
            IdNode id = new IdNode(l,i);
            oc.add(0, id); RESULT = oc;:}
    ;

opt_comma ::= COMMA id_list:il {:RESULT = il;:} 
    | /* empty */ {:RESULT = new ArrayList<IdNode>();:}
    ;

unary_operator ::= MINUS:m 
    {:  Location l = new Location(mleft, mright);
        RESULT =  new MinusNode(l);:}
    |   NOT:n {:  
        Location l = new Location(nleft, nright); RESULT = new NotNode(l);:}
    |   NOT_OP:no {:    Location l = new Location(noleft, noright); RESULT = new NotOperatorNode(l);:}
    ;
    
postfix_expression ::= primary_expression:pe {:RESULT = pe;:}
    |   postfix_expression:pe LPARENTHESIS RPARENTHESIS 
        {:  Location l = new Location(peleft, peright);
            IdNode id = (IdNode)pe;
            FunctionCallNode fcn = new FunctionCallNode(l,id); RESULT = fcn;:}
    |   postfix_expression:pe LPARENTHESIS argument_expression_list:ael RPARENTHESIS 
        {:  Location l = new Location(peleft, peright);
        IdNode id = (IdNode)pe;
            FunctionCallNode fcn = new FunctionCallNode(l,id, ael); RESULT = fcn;:}
    |   postfix_expression:pe INC_OP:i
        {: Location l = new Location(ileft, iright);
           PosIncrementOperatorNode pion = new PosIncrementOperatorNode(l,pe); RESULT = pion;:}
    |   postfix_expression:pe DEC_OP:d
        {: Location l = new Location(dleft, dright);
           PosDecrementOperatorNode pdon = new PosDecrementOperatorNode(l,pe); RESULT = pdon;:}
    ;

argument_expression_list::= assignment_expression:ae 
        {:  ArrayList<ExpressionNode> aeln = new ArrayList<>();
            aeln.add(ae); RESULT = aeln;:}
    |   argument_expression_list:ael COMMA assignment_expression:ae 
        {:ArrayList<ExpressionNode> aeln = new ArrayList<>();
          if(ael != null)
            aeln.addAll(ael);
          aeln.add(ae); RESULT = aeln; :}
    ;

primary_expression ::= ID:i
        {: Location l = new Location(ileft, iright);
           IdNode idn = new IdNode(l,i); RESULT = idn;:}
    |   INT_LITERAL:il
        {: Location l = new Location(illeft, ilright);
           IntLiteralNode iln = new IntLiteralNode(l, il);
           RESULT =iln;:}
    |   STRING_LITERAL:sl
        {:  Location l = new Location(slleft,slright); RESULT = new StringLiteralNode(l,sl);:}
    |   LPARENTHESIS expression:e RPARENTHESIS {:RESULT = e;:} 
    ;

assignment_operator ::= ASSIGNMENT_OP:ao
    {: Location l = new Location(aoleft, aoright);
       AssignmentOperatorNode aon = new AssignmentOperatorNode(l); RESULT = aon;:}
    ;

program ::= MODULE ID SEMICOLON initial_begin functions_list MODULE_END
    ;

initial_begin ::= INITIAL DEVICE DEVICE_MODEL SEMICOLON global_variables INITIAL_END
    | /* empty */
    ;

global_variables ::= global_variables pin_declaration
    | global_variables pin_definition
    | global_variables set_declaration
    | global_variables set_assignation_statement
    | /* empty */
    ;

pin_declaration ::= id_list PIN pin_list SEMICOLON

pin_list ::= INT_LITERAL pin_listp
    ;

pin_listp ::= COMMA pin_list
    | /* empty */
    ;

pin_definition ::= id_list ISTYPE pin_type SEMICOLON
    ;

pin_type ::= OUTPUT
    |   INPUT
    ;

set_declaration ::= ID EQUAL_OP LSQUARE_BRACKET id_list RSQUARE_BRACKET SEMICOLON
    ;

set_assignation_statement ::= LSQUARE_BRACKET id_list RSQUARE_BRACKET EQUAL_OP expression SEMICOLON
    ;

functions_list ::= function
    | functions_list function
    | /* empty */
    ;

function ::= FUNCTION ID LPARENTHESIS id_list RPARENTHESIS variable_declaration statement_list FUNCTION_END
    ;  

variable_declaration ::= VAR id_list SEMICOLON
    ;
    
statement_list ::= statement
    | statement_list statement
    ;

statement ::= expression_statement
    |   set_assignation_statement
    |   if_statement
    |   iteration_statement
    |   jump_statement
    |   PRINT expression SEMICOLON
    ;

jump_statement ::= BREAK SEMICOLON
    |   RETURN SEMICOLON
    |   RETURN expression SEMICOLON
    ;

iteration_statement ::= WHILE LPARENTHESIS expression RPARENTHESIS statement WHILE_END
    |   FOR LPARENTHESIS expression_statement expression_statement expression RPARENTHESIS statement FOR_END    
    ;

if_statement ::= IF LPARENTHESIS expression RPARENTHESIS statement IF_END
    | IF LPARENTHESIS expression RPARENTHESIS statement_or_null ELSE statement IF_END
    ;

expression_statement ::= SEMICOLON
    |   expression SEMICOLON
    ;       